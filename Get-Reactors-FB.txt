(function () {
  // Helper to build a short CSS-like path for logging
  function getCssPath(el) {
    if (!el || el.nodeType !== 1) return '';
    const parts = [];
    while (el && el.nodeType === 1 && el.tagName.toLowerCase() !== 'html') {
      let part = el.tagName.toLowerCase();
      if (el.id) {
        part += `#${el.id}`;
        parts.unshift(part);
        break;
      }
      if (el.classList && el.classList.length) {
        const classes = Array.from(el.classList).slice(0, 3).map(c => c.replace(/\s+/g, ''));
        if (classes.length) part += '.' + classes.join('.');
      }
      const parent = el.parentElement;
      if (parent) {
        const siblingsOfSameTag = Array.from(parent.children).filter(ch => ch.tagName === el.tagName);
        if (siblingsOfSameTag.length > 1) {
          const idx = Array.prototype.indexOf.call(parent.children, el) + 1;
          part += `:nth-child(${idx})`;
        }
      }
      parts.unshift(part);
      el = el.parentElement;
    }
    return parts.join(' > ');
  }

  function isScrollable(element) {
    try {
      const style = window.getComputedStyle(element);
      const overflowY = style.overflowY;
      const overflowX = style.overflowX;
      const isOverflowScrollable = (overflowY === 'scroll' || overflowY === 'auto') ||
                                   (overflowX === 'scroll' || overflowX === 'auto');

      return isOverflowScrollable &&
             (element.scrollHeight > element.clientHeight || element.scrollWidth > element.clientWidth);
    } catch (e) {
      return false;
    }
  }

  const allElements = document.querySelectorAll('*');
  const scrollableElements = Array.from(allElements).filter(isScrollable);

  if (scrollableElements.length === 0) {
    console.log('No scrollable elements found on the page.');
    return;
  }

  // Select the first scrollable element that:
  //  - has non-zero rendered height (visible)
  //  - is inside a dialog (closest ancestor div[role="dialog"] exists)
  const preferredScrollable = scrollableElements.find(el => {
    try {
      const rect = el.getBoundingClientRect();
      const hasHeight = rect && Math.round(rect.height) !== 0;
      const inDialog = !!(el.closest && el.closest('div[role="dialog"]'));
      return hasHeight && inDialog;
    } catch (e) {
      return false;
    }
  });

  // Fallback: the original last scrollable element
  const lastScrollableElement = scrollableElements[scrollableElements.length - 1];
  const scrollTarget = preferredScrollable || lastScrollableElement;

  if (preferredScrollable) {
    console.log('Selected first scrollable element that is inside a dialog and has non-zero height:');
    console.log(' - cssPath:', getCssPath(preferredScrollable));
    console.log(' - bounding rect:', (function(r){ return { top: Math.round(r.top), left: Math.round(r.left), width: Math.round(r.width), height: Math.round(r.height) }; })(preferredScrollable.getBoundingClientRect()));
  } else {
    console.warn('No scrollable element inside a dialog with non-zero height was found. Falling back to the last scrollable element found on the page:');
    console.log(' - cssPath:', getCssPath(lastScrollableElement));
    console.log(' - bounding rect:', (function(r){ return { top: Math.round(r.top), left: Math.round(r.left), width: Math.round(r.width), height: Math.round(r.height) }; })(lastScrollableElement.getBoundingClientRect()));
  }

  let facebookLinks = [];
  let userRequestedStop = false;

  // Listen for the "stop" signal from the user
  window.addEventListener('message', (event) => {
    if (event.data === 'stop') {
      userRequestedStop = true;
      // Remove any existing overlays immediately when stop is signaled programmatically
      try {
        const overlays = Array.from(document.querySelectorAll('.fb-extractor-stop-overlay'));
        for (const ov of overlays) {
          try { ov.remove(); } catch (e) {}
        }
      } catch (e) {}
    }
  });

  // Normalize Facebook link according to the rule:
  // - If pathname ends with 'profile.php' and there's an 'id' search param, keep only "?id=..."
  // - Otherwise keep only origin + pathname (drop whole query)
  function normalizeFacebookHref(href) {
    try {
      const url = new URL(href, document.location.origin);
      const pathname = url.pathname || '';
      const origin = url.origin || `${location.protocol}//${location.host}`;
      const normalizedPath = pathname.endsWith('/') && pathname !== '/' ? pathname.slice(0, -1) : pathname;

      if (normalizedPath.endsWith('/profile.php') || normalizedPath === '/profile.php') {
        const id = url.searchParams.get('id');
        if (id) {
          return `${origin}${normalizedPath}?id=${encodeURIComponent(id)}`;
        }
      }

      return `${origin}${normalizedPath}`;
    } catch (e) {
      try {
        const raw = String(href);
        if (raw.includes('profile.php') && raw.includes('id=')) {
          const upToAmp = raw.split('&')[0];
          return upToAmp;
        }
        return raw.split('?')[0];
      } catch (err) {
        return href;
      }
    }
  }

  // Heuristic to extract a meaningful name from an <a> element while avoiding profile picture text/alt.
  function extractNameFromAnchor(a) {
    if (!a) return null;

    function isVisible(el) {
      try {
        if (!el) return false;
        const target = el.nodeType === Node.TEXT_NODE ? el.parentElement : el;
        if (!target) return false;
        const rects = target.getClientRects();
        if (!rects || rects.length === 0) return false;
        const style = window.getComputedStyle(target);
        if (!style) return false;
        if (style.display === 'none' || style.visibility === 'hidden' || parseFloat(style.opacity) === 0) return false;
        return true;
      } catch (e) {
        return false;
      }
    }

    const photoRegex = /profile\s*picture|profile\s*photo|profilepic|profile-pic|avatar|photo\s*of|image|picture|ảnh|hình|foto\s*de\s*perfil|profilbild/i;

    try {
      const imgs = a.querySelectorAll('img, svg');
      if (imgs.length > 0) {
        let hasVisibleTextSibling = false;
        for (const node of a.childNodes) {
          if (node.nodeType === Node.TEXT_NODE) {
            const txt = node.nodeValue ? node.nodeValue.trim() : '';
            if (txt && !photoRegex.test(txt) && isVisible(node)) {
              hasVisibleTextSibling = true;
              break;
            }
          } else if (node.nodeType === Node.ELEMENT_NODE) {
            const nodeName = node.nodeName && node.nodeName.toUpperCase();
            if (nodeName !== 'IMG' && nodeName !== 'SVG') {
              const txt = node.textContent ? node.textContent.trim() : '';
              if (txt && !photoRegex.test(txt) && isVisible(node)) {
                hasVisibleTextSibling = true;
                break;
              }
            }
          }
        }
        if (!hasVisibleTextSibling) {
          // intentionally do not extract from image-only anchors' alt text here
        }
      }
    } catch (e) {
      // ignore and continue
    }

    try {
      const walker = document.createTreeWalker(a, NodeFilter.SHOW_TEXT, {
        acceptNode(node) {
          const text = node.nodeValue ? node.nodeValue.trim() : '';
          if (!text) return NodeFilter.FILTER_REJECT;

          let p = node.parentNode;
          while (p && p !== a) {
            const nodeName = p.nodeName && p.nodeName.toUpperCase();
            if (nodeName === 'IMG' || nodeName === 'SVG') return NodeFilter.FILTER_REJECT;
            try {
              if (p.getAttribute && p.getAttribute('role') === 'img') return NodeFilter.FILTER_REJECT;
            } catch (e) {}
            p = p.parentNode;
          }

          if (photoRegex.test(text)) return NodeFilter.FILTER_REJECT;
          const parentEl = node.parentElement || a;
          if (!isVisible(parentEl)) return NodeFilter.FILTER_REJECT;

          return NodeFilter.FILTER_ACCEPT;
        }
      }, false);

      let textNode = walker.nextNode();
      while (textNode) {
        const candidate = textNode.nodeValue.trim();
        if (candidate && candidate.length >= 2 && candidate.length <= 80) {
          if (/[A-Za-z\u00C0-\u024F\u0100-\u017F\u0400-\u04FF]/.test(candidate)) {
            return candidate;
          }
        }
        textNode = walker.nextNode();
      }
    } catch (e) {}

    try {
      const candidates = Array.from(a.querySelectorAll('span, div, strong, b, em, p, h1, h2, h3'));
      candidates.sort((x, y) => (y.textContent || '').length - (x.textContent || '').length);
      for (const c of candidates) {
        const txt = c.textContent ? c.textContent.trim() : '';
        if (!txt) continue;
        if (photoRegex.test(txt)) continue;
        if (!isVisible(c)) continue;
        if (txt.length >= 2 && txt.length <= 80 && /[A-Za-z\u00C0-\u024F\u0100-\u017F\u0400-\u04FF]/.test(txt)) {
          return txt;
        }
      }
    } catch (e) {}

    try {
      const aria = a.getAttribute && a.getAttribute('aria-label');
      if (aria && aria.trim() && !photoRegex.test(aria) && /[A-Za-z\u00C0-\u024F\u0100-\u017F\u0400-\u04FF]/.test(aria)) {
        return aria.trim();
      }
    } catch (e) {}

    try {
      const title = a.getAttribute && a.getAttribute('title');
      if (title && title.trim() && !photoRegex.test(title) && /[A-Za-z\u00C0-\u024F\u0100-\u017F\u0400-\u04FF]/.test(title)) {
        return title.trim();
      }
    } catch (e) {}

    return null;
  }

  // Function to extract Facebook links from the correct dialog
  function getFacebookLinks() {
    const dialogDivs = document.querySelectorAll('div[role="dialog"]');

    for (const dialog of dialogDivs) {
      const links = dialog.querySelectorAll('a[href*="facebook.com"]');
      if (links.length > 0) {
        const linksArray = Array.from(links).map(a => ({
          raw: a.href,
          link: normalizeFacebookHref(a.href)
        }));

        const uniqueLinks = [];
        const seenLinks = new Set();
        for (const item of linksArray) {
          if (!seenLinks.has(item.link)) {
            uniqueLinks.push(item);
            seenLinks.add(item.link);
          }
        }

        return uniqueLinks;
      }
    }

    return [];
  }

  // Create an on-page input so the user can type "stop" and press Enter
  function createStopInputOverlay() {
    try {
      // Prevent creating multiple overlays from the same run
      if (document.querySelector('.fb-extractor-stop-overlay')) return;

      // Use a run-unique ID so old observers from prior runs (if any) won't match/remove this overlay
      const overlayId = 'fb-extractor-stop-overlay-' + Math.random().toString(36).slice(2, 9);

      const wrapper = document.createElement('div');
      wrapper.className = 'fb-extractor-stop-overlay';
      wrapper.id = overlayId;
      wrapper.style.position = 'fixed';
      wrapper.style.right = '12px';
      wrapper.style.top = '12px';
      wrapper.style.zIndex = 2147483647; // very high
      wrapper.style.background = 'rgba(0,0,0,0.7)';
      wrapper.style.color = '#fff';
      wrapper.style.padding = '8px';
      wrapper.style.borderRadius = '6px';
      wrapper.style.fontFamily = 'system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial';
      wrapper.style.fontSize = '12px';
      wrapper.style.boxShadow = '0 2px 10px rgba(0,0,0,0.5)';
      wrapper.style.display = 'flex';
      wrapper.style.alignItems = 'center';
      wrapper.style.gap = '8px';
      wrapper.style.maxWidth = '320px';

      const label = document.createElement('span');
      label.textContent = 'Type "stop" and press Enter';
      label.style.whiteSpace = 'nowrap';

      const form = document.createElement('form');
      form.style.display = 'flex';
      form.style.gap = '6px';
      form.style.alignItems = 'center';

      const input = document.createElement('input');
      input.type = 'text';
      input.placeholder = 'stop';
      input.style.padding = '6px 8px';
      input.style.borderRadius = '4px';
      input.style.border = '1px solid rgba(255,255,255,0.15)';
      input.style.background = 'rgba(255,255,255,0.05)';
      input.style.color = '#fff';
      input.style.outline = 'none';
      input.style.width = '110px';

      const btn = document.createElement('button');
      btn.type = 'submit';
      btn.textContent = 'OK';
      btn.style.padding = '6px 8px';
      btn.style.border = 'none';
      btn.style.borderRadius = '4px';
      btn.style.background = '#2d88ff';
      btn.style.color = '#fff';
      btn.style.cursor = 'pointer';

      form.appendChild(input);
      form.appendChild(btn);
      wrapper.appendChild(label);
      wrapper.appendChild(form);
      document.body.appendChild(wrapper);

      // Focus the input so user can immediately type
      input.focus();

      let obs = null;

      function removeOverlay() {
        try {
          const el = document.getElementById(overlayId);
          if (el) el.remove();
        } catch (e) {}
        try {
          if (obs) obs.disconnect();
        } catch (e) {}
      }

      form.addEventListener('submit', (e) => {
        e.preventDefault();
        const val = (input.value || '').trim().toLowerCase();
        if (val === 'stop') {
          userRequestedStop = true;
          removeOverlay();
          console.log('Stop command received via overlay input.');
        } else {
          // small feedback: clear and briefly flash
          input.value = '';
          input.style.transition = 'box-shadow 0.15s';
          input.style.boxShadow = '0 0 0 3px rgba(255,0,0,0.15)';
          setTimeout(() => {
            input.style.boxShadow = '';
          }, 250);
        }
      });

      // allow clicking the label to focus
      label.addEventListener('click', () => input.focus());

      // remove overlay on stop via other means; observer belongs to this run and will be disconnected in removeOverlay
      obs = new MutationObserver(() => {
        if (userRequestedStop) {
          removeOverlay();
        }
      });
      obs.observe(document.documentElement || document.body, { childList: true, subtree: true });

    } catch (e) {
      console.warn('Could not create stop overlay input:', e);
    }
  }

  // Function to scroll and load content while capturing Facebook links
  function autoScrollAndCapture(element) {
    if (!element) {
      console.error('No element provided to autoScrollAndCapture.');
      return;
    }

    // create the overlay to allow typing "stop"
    createStopInputOverlay();

    const interval = setInterval(() => {
      if (userRequestedStop) {
        clearInterval(interval);
        console.log('User signaled to stop.');
        console.log('Processing to csv... Please wait...');
        populateNamesAndGenerateCSV(facebookLinks);
        return;
      }

      // Scroll down by a small amount (tweak if needed)
      try {
        element.scrollBy(0, 1000);
      } catch (e) {
        // fallback for some elements
        element.scrollTop = element.scrollTop + 1000;
      }

      // Extract current Facebook links from the dialog(s)
      const currentFacebookLinks = getFacebookLinks();

      // Merge the new links into the main list and remove duplicates by normalized link
      const mergedMap = new Map(facebookLinks.map(i => [i.link, i]));
      for (const item of currentFacebookLinks) {
        if (!mergedMap.has(item.link)) {
          mergedMap.set(item.link, item);
        } else {
          const existing = mergedMap.get(item.link);
          if (!existing.raw && item.raw) existing.raw = item.raw;
        }
      }
      facebookLinks = Array.from(mergedMap.values());

      console.log(`Captured Facebook links: ${facebookLinks.length}`);
    }, 300);
  }

  // Function to populate names by searching the page for `<a>` tags with the normalized link in their href
  function populateNamesAndGenerateCSV(data) {
    data.forEach(item => {
      const anchors = Array.from(document.querySelectorAll('a[href]'));
      const candidates = anchors.filter(a => {
        try {
          const candidateHrefNorm = normalizeFacebookHref(a.href);
          return candidateHrefNorm === item.link || a.href.includes(item.link) || (item.raw && a.href.includes(item.raw));
        } catch (e) {
          return false;
        }
      });

      let foundName = null;
      for (const a of candidates) {
        const name = extractNameFromAnchor(a);
        if (name) {
          foundName = name;
          break;
        }
      }

      item.name = foundName || "Unnamed";
    });

    generateCSV(data);
  }

  // Function to generate CSV and output it
  function generateCSV(data) {
    let csvContent = "Name,Link\r\n";
    data.forEach(item => {
      const nameEsc = String(item.name).replace(/"/g, '""');
      const linkEsc = String(item.link).replace(/"/g, '""');
      csvContent += `"${nameEsc}","${linkEsc}"\r\n`;
    });

    const blob = new Blob([csvContent], { type: "text/csv;charset=utf-8;" });
    const dlLink = document.createElement("a");
    const url = URL.createObjectURL(blob);
    dlLink.setAttribute("href", url);
    dlLink.setAttribute("download", "react.csv");
    dlLink.style.visibility = "hidden";
    document.body.appendChild(dlLink);
    dlLink.click();
    document.body.removeChild(dlLink);
    URL.revokeObjectURL(url);

    console.log("CSV file generated and downloaded.");
  }

  // Start auto-scrolling and capturing Facebook links using the chosen scroll target
  autoScrollAndCapture(scrollTarget);

  console.log("Started auto-scrolling on selected element. To stop and export CSV run: window.postMessage('stop', '*');");
})();
